\documentclass{article}


\usepackage[utf8]{inputenc}
\usepackage[english,polish]{babel}
\usepackage{polski}
\usepackage{listings}
\usepackage{color}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{ifthen}
\usepackage[margin=1in]{geometry}

\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}


\def\localedef#1#2{
\ifthenelse{ \equal{\locale}{#1} }{
  \selectlanguage{#2}
  \expandafter\def\csname#1\endcsname ##1{##1}
  }{
  \expandafter\def\csname#1\endcsname ##1{}
  }
}

\providecommand\locale{\lang}

\localedef{en}{english}
\localedef{pl}{polish}


\lstset{literate=
{ł}{{\l}}1 {Ł}{{\L}}1 {ą}{{\k{a}}}1 {Ą}{{\k{A}}}1 {ę}{{\k{e}}}1 {Ę}{{\k{E}}}1 {ś}{{\'s}}1 {Ś}{{\'S}}1 {ć}{{\'c}}1 {Ć}{{\'C}}1 
{ń}{{\'n}}1 {Ń}{{\'N}}1 {ó}{{\'o}}1 {Ó}{{\'O}}1 {ź}{{\'z}}1 {Ź}{{\'Z}}1 {ż}{{\.z}}1 {Ż}{{\.Z}}1
 {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
  {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
  {à}{{\`a}}1 {è}{{\'e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
  {À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
  {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
  {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
  {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
  {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
  {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
  {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
  {€}{{\EUR}}1 {£}{{\pounds}}1
}

\lstdefinelanguage{ml}{
  keywords={true, false, null, if, while},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
	language=ml
}

\newcommand{\begi}{
	\begin{itemize}
}

\newcommand{\enit}{
	\end{itemize}
}

\newcommand{\descr}{
	\pl{Krótki opis :}
	\en{Short description :}
}

\newcommand{\opers}{
	\pl{Operatory: }
	\en{Operators: }
}

\newcommand{\methods}{
	\pl{Metody: }
	\en{Methods: }
}

\newcommand{\consts}{
	\pl{Stałe: }
	\en{Constants: }
}

\newcommand{\args}{
	\pl{Argumenty: }
	\en{Arguments: }
}

\newcommand{\returns}{
	\pl{Typ zwracany: }
	\en{Returned type: }
}

\newcommand{\extends}{
	\pl{Dziedziczy po: }
	\en{Extends: }
}

\begin{document}

\center
\huge
\pl{Język skryptowy Plezuro}
\en{Plezuro scripting language}
\\

\pl{Dokumentacja}
\en{Documentation}
\\

\includegraphics[scale=0.5]{../resources/logo.png}

\pagebreak
\flushleft
\normalsize

\section{
	\pl{Autorzy}
	\en{Authors}
}

\pl{Uczelnia}
\en{University}
: 
\pl{Politechnika Śląska}
\en{Silesian University of Technology}
\\

\pl{Wydział}
\en{Faculty}
: 
\pl{Wydział Matematyki Stosowanej}
\en{Faculty of Applied Mathematics}
\\

\pl{Rok akademicki}
\en{Academic year}
: 2013/2014\\

\pl{Kierunek}
\en{Path}
: 
\pl{Informatyka}
\en{Computer Science}\\

\pl{Semestr}
\en{Semester}
: IV\\

\pl{Nazwiska}
\en{Names}
\\
	\begi
		\item
			Piotr Sroczkowski\\
			\pl{Pomysł, język skryptowy, dokumentacja}
			\en{Idea, scripting language,  documentation}
	\enit

\section{
	\pl{Dane techniczne}
	\en{Technical information}
}

\pl{Język}
\en{Language}
: c$^\sharp$ 5.0\\

\pl{Platforma}
\en{Platform}
: Mono 3.2.8\\

\pl{Kompilator}
\en{Compiler}
: gmcs 3.2.8.0\\

\pl{System kontroli wersji}
\en{Version control system}
: git 1.9.1

\pl{Adres publicznego repozytorium}
\en{Public repository address}
: \url{https://github.com/oprogramador/repo}

\pl{Licencja}
\en{Licence}
: GNU GPL 2.0

\section{
	\pl{Dla użytkownika}
	\en{User interface specification}
}

\subsection{
	\pl{Krótki opis}
	\en{Short description}
}

\pl{Został zaimplementowany język skryptowy. W
	oparciu na nim działa nierelacyjna baza danych.}
\en{A scripting language has been implemented. On its base a non-relational
	database works.
}

\subsection{
    \pl{Główne zasady}
    \en{Main principles}
}
\begin{enumerate}
    \item
        \pl{Kod powinien być możliwie jak najkrótszy.}
        \en{The code should be as short as possible.}
    \item
        \pl{Moduł, funkcja oraz plik źródłowy są równoznacze.}
        \en{The module, the function and the source file are equivalent one to each other.}
    \item
        \pl{Wszystkie przyjęte zasady są bez jakiegokolwiek wyjątku.}
        \en{All applied rules are without any exception.}
    \item
        \pl{Nie ma nic, czego nie dałoby się zmienić (włącznie z klasami, które są w pełni dynamiczne).}
        \en{There is nothing that cannot be changed (including classes which are fully dynamic).}
    \item
        \pl{Nie ma słów kluczowych.}
        \en{There is no keywords.}
    \item
        \pl{Jawne (kodowanie) jest zawsze lepsze nić domniemane.}
        \en{Explicit is always better than implicit.}
\end{enumerate}

\subsection{
	\pl{Krótki przewodnik}
	\en{Short tutorial}
}

\subsubsection{
	\pl{Prosty przykład}
	\en{Simple example}
}
%\lstinputlisting{../src/ml_src/primes.ml}

\subsubsection{
	\pl{Komentarze}
	\en{Comments}
}
%\lstinputlisting{../src/ml_src/comments.ml}

\subsubsection{
	\pl{Zmienne}
	\en{Variables}
}
\pl{Przy deklaracji zmiennej, piszemy znak '\$', określa to zasięg zmiennej.}
\en{At declaring before the variable name you should write '\$', it determines the variable scope.}
%\lstinputlisting{../src/ml_src/var.ml}

\subsubsection{
	\pl{Klonowanie a referencja}
	\en{Cloning vs reference}
}
%\lstinputlisting{../src/ml_src/ref.ml}

\subsubsection{
	\pl{Wbudowane klasy (typy)}
	\en{Built-in classes (types)}
}
%\lstinputlisting{../src/ml_src/classes.ml}

\subsubsection{
	\pl{Indeksowanie}
	\en{Indexing}
}
%\lstinputlisting{../src/ml_src/index.ml}

\subsubsection{
	\pl{Krotki}
	\en{Tuples}
}
%\lstinputlisting{../src/ml_src/tuple.ml}

\subsubsection{
	\pl{Wyrażenia warunkowe}
	\en{Conditional expressions}
}
%\lstinputlisting{../src/ml_src/if.ml}

\subsubsection{
	\pl{Pętle}
	\en{Loops}
}
%\lstinputlisting{../src/ml_src/loop.ml}

\subsubsection{
	\pl{Procedury}
	\en{Procedures}
}
%\lstinputlisting{../src/ml_src/proc.ml}

\subsubsection{
	\pl{Operacje na plikach}
	\en{File operations}
}
%\lstinputlisting{../src/ml_src/file.ml}

\subsubsection{
	\pl{Generowanie tabelki html}
	\en{Html table generation}
}
%\lstinputlisting{../src/ml_src/html.ml}

\subsubsection{
	\pl{Klasy zdefiniowane przez użytkownika}
	\en{User-defined classes}
}
%\lstinputlisting{../src/ml_src/obj.ml}


\subsubsection{
	\pl{Kolejność operatorów dwuargumentowych (od tych wykonywanych na końcu)}
	\en{Two argument operators precedence (from those executed at the end)}
}

		\item \verb+;+	
		\item \verb+:=+
		\item \verb+=+
		\item \verb+,+ 	
		\item \verb+<->+
		\item \verb+<<+
		\item \verb+>>+	
		\item \verb+?+	
		\item \verb+|+	
		\item \verb+&+	
		\item \verb+<=>+	
		\item \verb+>=+	
		\item \verb+>+	
		\item \verb+<=+	
		\item \verb+<+	
		\item \verb+!=+	
		\item \verb+==+	
		\item \verb+===+	
		\item \verb+=~+
		\item \verb+++
		\item \verb+-+	
		\item \verb+%+	
		\item \verb+*+
		\item \verb+/+	
		\item \verb+^+
		\item
			\pl{Razem}
			\en{Together}
			\begi
				\item \verb+^^+
				\item \verb+.+
			\enit
		\item \verb+..+
		\item \verb+:+	

\subsubsection{
	\pl{Operatory jednoargumentowe}
	\en{One argument operators}
}
		\item \verb+!+	
		\item \verb+&&+	
		\item \verb+**+	
		\item \verb+#+	
		\item \verb-++-
		\item \verb+--+
		\item \verb+@+

\subsubsection{
	\pl{Wbudowane pakiety, klasy, metody, operatory i stałe}
	\en{Built-in packages, classes, methods, operators and constants}
}

\begi
	\item package Lang
	\begi
			\item class Boolean\\
			\extends [Object]
			\begi
				\item \descr
					\pl{Wartość logiczna}
					\en{Boolean value}
				\item \opers
				\begi
					\item\verb+?+\\
						\args (Boolean b, Pair p)\\
						\returns Object\\
						\descr
						\pl{Gdy b ma wartość \textit{true} zwraca pierwszą wartość z pary p, w przeciwnym razie zwraca drugą wartość.}
						\en{If b is \textit{true}, it returns the first value of pair p, in other case it returns the second value.}
					\item\verb+|+\\
						\args (Boolean a, Boolean b)\\
						\returns Boolean\\
						\descr
						\pl{Alternatywa logiczna}
						\en{Logic alternative}
					\item\verb+&+\\
						\args (Boolean a, Boolean b)\\
						\returns Boolean\\
						\descr
						\pl{Koniunkcja logiczna}
						\en{Logical conjunction}
					\item\verb+!+\\
						\args (Boolean b)\\
						\returns Boolean
						\descr
						\pl{Przeczenie logiczne}
						\en{Logical negation}
				\enit
				\item \methods
				\begi
					\item if\\
						\args (Boolean b, Procedure t, Procedure f)\\
						\returns Object\\
						\descr
						\pl{Instrukcja warunkowa - jeśli b ma wartość \textit{true}, wykonywana jest procedura t, 
						w przeciwnym razie wykonywana jest procedura f.}
						\en{Conditional instruction - if b is \textit{true}, the procedure t is executed,
						otherwise the procedure f is executed.}
				\enit
				\item \consts
				\begi
					\item true\\
						\descr
						\pl{Prawda}
						\en{True}
					\item false\\
						\descr
						\pl{Fałsz}
						\en{False}
				\enit
			\enit


			\item class Class\\
			\extends [Object]
			\begi
				\item \descr
					\pl{Klasa}
					\en{Class}
				\item \methods
				\begi
					\item parents\\
						\args (Class c)\\
						\returns List\\
						\descr
						\pl{Zwraca wszystkie klasy bazowe (występuje dziedziczenie po wielu klasach).}
						\en{It returns all base classes (there is multiple inheritance).}
					\item package\\
						\args (Class c)\\
						\returns Package\\
						\descr
						\pl{Zwraca pakiet, do którego należy klasa.}
						\en{It returns the package that the class belongs to.}
				\enit
			\enit


			\item class Dictionary\\
			\extends [Object]
			\begi
				\item \descr
					\pl{Kolekcja słownik}
					\en{Dictionary container}
				\item \opers
				\begi
					\item\verb+<<+\\
						\args (Dictionary d, Pair p)\\
						\returns Dictionary\\
						\descr
						\pl{Dodaje parę klucz-wartość do słownika.}
						\en{It adds a pair key-value to the dictionary.}
				\enit
				\item \methods
				\begi
					\item ref\\
						\args (Dictionary d, Object key)\\
						\returns Object\\
						\descr
						\pl{Zwraca referencję do wartości zadanej przez klucz.}
						\en{It returns the reference to the value indicated by the key.}
					\item len\\
						\args (Dictionary d)\\
						\returns Number\\
						\descr
						\pl{Zwraca długość słownika.}
						\en{It returns the length of the dictionary.}
					\item contains\\
						\args (Dictionary d, Object key)\\
						\returns Boolean\\
						\descr
						\pl{Informacja, czy słownik zawiera podany klucz}
						\en{Information whether the dictionary contains the key.}
					\item keys\\
						\args (Dictionary d)\\
						\returns List\\
						\descr
						\pl{Zwraca listę wszystkich kluczy.}
						\en{It returns the list of all the keys.}
					\item remove\\
						\args (Dictionary d, Object key)\\
						\returns Dictionary\\
						\descr
						\pl{Zwraca nowy słownik z usuniętym kluczem.}
						\en{It returns the new dictionary with the removed key.}
				\enit
			\enit


			\item class DotFunc\\
			\extends [Object]
			\begi
				\item \descr
					\pl{Para (funkcja, pierwszy argument)}
					\en{Pair (function, first argument)}
				\item \opers
				\begi
					\item\verb+^^+\\
						\args (DotFunc d, Object o)\\
						\returns Object\\
						\descr
						\pl{Wywołuje funkcję dla podanych argumentów. Pierwszy argument jest zapamiętany,
						kolejne zawarte są w obiekcie o (obiekt klasy Empty traktowany jest jako brak argumentu,
						Tuple jako wiele argumentów, zaś innych klas jako pojedynczy argument.}
						\en{It calls the function with the arguments. The first argument is stored,
						the next ones are contained inside object o (Empty class object is treated as no arguments,
						Tuple as multiple arguments, other classes as singe argument.}
				\enit
			\enit


			\item class Empty\\
			\extends [Object]
			\begi
				\item \descr
					\pl{Pusta wartość}
					\en{Empty value}
				\item \methods
				\begi
					\item array\\
						\args (Empty e)\\
						\returns List\\
						\descr
						\pl{Zwraca pustą listę.}
						\en{It returns an empty list.}
				\enit
			\enit


			\item class Error\\
			\extends [Object]
			\begi
				\item \descr
					\pl{Błąd}
					\en{Error}
				\item \methods
				\begi
					\item msg\\
						\args (Error e)\\
						\returns String\\
						\descr
						\pl{Zwraca komunikat błędu.}
						\en{It returns the error message.}
				\enit
			\enit


			\item class List\\
			\extends [Object]
			\begi
				\item \descr
					\pl{Kolekcja lista}
					\en{List collection}
				\item \opers
				\begi
					\item\verb+<<+\\
						\args (List l, Object o)\\
						\returns List\\
						\descr
						\pl{Akcja \textit{push} - wrzucenie obiektu o do listy l.}
						\en{Pushing o object to l list.}
					\item\verb+>>+\\
						\args (List l, Reference r)\\
						\returns List\\
						\descr
						\pl{Akcja \textit{pop} - zrzucenie obiektu z listy l do referencji r.}
						\en{Popping an object from l list to r reference.}
					\item\verb|+|\\
						\args (List a, List b)\\
						\returns List\\
						\descr
						\pl{Konkatenacja dwóch list.}
						\en{Two lists concatenation.}
					\item\verb+*+\\
						\args (List l, Number n)\\
						\returns Object\\
						\descr
						\pl{n-krotne kopiowanie tablicy l.}
						\en{n-times copying of l list.}
				\enit
				\item \methods
				\begi
					\item get\\
						\args (List l, Number n)\\
						\returns Object\\
						\descr
						\pl{Zwraca n-ty element listy l.}
						\en{It returns n-th element of l list.}
					\item len\\
						\args (List l)\\
						\returns Number\\
						\descr
						\pl{Zwraca długość tablicy l.}
						\en{It returns l list length.}
					\item ref\\
						\args (List l, Number n)\\
						\returns Reference\\
						\descr
						\pl{Zwraca referencję do n-tego elementu listy l.}
						\en{It returns the reference to n-th element of l list.}
					\item each\\
						\args (List l, Procedure p)\\
						\returns Object\\
						\descr
						\pl{Iteracja listy l, wykonywanie procedury p dla każdego elementu.}
						\en{Iteration of l list, executing of p procedure for each element.}
					\item where\\
						\args (List l, Procedure p)\\
						\returns List\\
						\descr
						\pl{Selekcja elementów, dla których procedura p zwraca wartość \textit{true}.}
						\en{Selection of such elements that procedure p returns \textit{true}.}
					\item map\\
						\args (List l, Procedure p)\\
						\returns List\\
						\descr
						\pl{Mapowanie procedury p po liście l.}
						\en{Mapping of p procedure throw l list.}
					\item sort\\
						\args (List l)\\
						\returns List\\
						\descr
						\pl{Sortowanie.}
						\en{Sorting.}
					\item orderBy\\
						\args (List l, Procedure p)\\
						\returns List\\
						\descr
						\pl{Sortowanie według wartośc zwracanej przez procedurę p.}
						\en{Sorting by the value that p procedure returns.}
					\item orderByD\\
						\args (List l, Procedure p)\\
						\returns List\\
						\descr
						\pl{To samo co orderBy, ale w odwrotej kolejności.}
						\en{The same as orderBy but descending.}
					\item groupBy\\
						\args (List l, Procedure p)\\
						\returns List\\
						\descr
						\pl{Grupowanie według wartośc zwracanej przez procedurę p.}
						\en{Grouping by the value that p procedure returns.}
					\item reverse\\
						\args (List l)\\
						\returns List\\
						\descr
						\pl{Odwracanie listy.}
						\en{List reversing.}
					\item max\\
						\args (List l)\\
						\returns Object\\
						\descr
						\pl{Zwraca maksymalną wartość.}
						\en{It returns the max value.}
					\item min\\
						\args (List l)\\
						\returns Object\\
						\descr
						\pl{Zwraca minimalną wartość.}
						\en{It returns the min value.}
					\item median\\
						\args (List l)\\
						\returns Object\\
						\descr
						\pl{Zwraca medianę.}
						\en{It returns the median.}
					\item remove\\
						\args (List l, Number n)\\
						\returns List\\
						\descr
						\pl{Zwraca listę z usuniętym elementem w indeksie n.}
						\en{It returns the list with removed element at n index.}
					\item toSet\\
						\args (List l)\\
						\returns Set\\
						\descr
						\pl{Konwertuje do zbioru (\textit{set}).}
						\en{It converts to the set collection.}
					\item html\\
						\args (List l)\\
						\returns String\\
						\descr
						\pl{Zwraca tabelką w html.}
						\en{It returns an html table.}
				\enit
			\enit


			\item class NullClass\\
			\extends [Object]
			\begi
				\item \descr
					\pl{Wartość null}
					\en{Null value}
				\item \consts
				\begi
					\item null\\
						\descr
						\pl{Null}
						\en{Null}
				\enit
			\enit


			\item class Number\\
			\extends [Object]
			\begi
				\item \descr
					\pl{Liczba rzeczywista}
					\en{Real number}
				\item \opers
				\begi
					\item\verb|+|\\
						\args (Number a, Number b)\\
						\returns Number\\
						\descr
						\pl{Dodawanie.}
						\en{Addition.}
					\item\verb+-+\\
						\args (Number a, Number b)\\
						\returns Number\\
						\descr
						\pl{Odejmowanie.}
						\en{Subtraction.}
					\item\verb-*-\\
						\args (Number a, Number b)\\
						\returns Number\\
						\descr
						\pl{Mnożenie.}
						\en{Multiplication.}
					\item\verb+/+\\
						\args (Number a, Number b)\\
						\returns Number\\
						\descr
						\pl{Dzielenie.}
						\en{Division.}
					\item\verb+^+\\
						\args (Number a, Number b)\\
						\returns Number\\
						\descr
						\pl{Potęgowanie.}
						\en{Power.}
					\item\verb|++|\\
						\args (Number a)\\
						\returns Number\\
						\descr
						\pl{Inkrementacja.}
						\en{Incrementation.}
					\item\verb+--+\\
						\args (Number a)\\
						\returns Number\\
						\descr
						\pl{Dekrementacja.}
						\en{Decrementation.}
				\enit
				\item \methods
				\begi
					\item chr\\
						\args (Number n)\\
						\returns String\\
						\descr
						\pl{Zwraca znak o podanym kodzie ASCII n.}
						\en{It returns the character with ASCII code n.}
					\item sin\\
						\args (Number n)\\
						\returns Number\\
						\descr
						\pl{Sinus.}
						\en{Sine.}
					\item cos\\
						\args (Number n)\\
						\returns Number\\
						\descr
						\pl{Cosinus.}
						\en{Cosine.}
					\item tan\\
						\args (Number n)\\
						\returns Number\\
						\descr
						\pl{Tangens.}
						\en{Tangent.}
					\item asin\\
						\args (Number n)\\
						\returns Number\\
						\descr
						\pl{Arcus sinus.}
						\en{Arcsine.}
					\item acos\\
						\args (Number n)\\
						\returns Number\\
						\descr
						\pl{Arcus cosinus.}
						\en{Arccosine.}
					\item atan\\
						\args (Number n)\\
						\returns Number\\
						\descr
						\pl{Arcus tangens.}
						\en{Arctangent.}
					\item sinh\\
						\args (Number n)\\
						\returns Number\\
						\descr
						\pl{Sinus hiperboliczny.}
						\en{Hyperbolic sine.}
					\item cosh\\
						\args (Number n)\\
						\returns Number\\
						\descr
						\pl{Cosinus hiperboliczny.}
						\en{Hyperbolic cosine.}
					\item tanh\\
						\args (Number n)\\
						\returns Number\\
						\descr
						\pl{Tangens hiperboliczny.}
						\en{Hyperbolic tangent.}
					\item round\\
						\args (Number n)\\
						\returns Number\\
						\descr
						\pl{Zaokrąglenie.}
						\en{Rounding.}
					\item floor\\
						\args (Number n)\\
						\returns Number\\
						\descr
						\pl{Zaokrąglenie w dół.}
						\en{Flooring.}
					\item ceil\\
						\args (Number n)\\
						\returns Number\\
						\descr
						\pl{Zaokrąglenie do góry.}
						\en{Ceiling.}
					\item abs\\
						\args (Number n)\\
						\returns Number\\
						\descr
						\pl{Wartość absolutna.}
						\en{Absolut value.}
					\item ln\\
						\args (Number n)\\
						\returns Number\\
						\descr
						\pl{Logarytm naturalny.}
						\en{Natural logarithm.}
					\item sqrt\\
						\args (Number n)\\
						\returns Number\\
						\descr
						\pl{Pierwiastek kwadratowy.}
						\en{Square root.}
					\item fib\\
						\args (Number n)\\
						\returns Number\\
						\descr
						\pl{N-ty element ciągu Fibonacciego.}
						\en{N-th element of the Fibonacci sequence.}
				\enit
				\item \consts
				\begi
					\item pi\\
						\descr
						\pl{Liczba pi}
						\en{Pi number}
					\item e\\
						\descr
						\pl{Liczba e}
						\en{E number}
				\enit
			\enit


			\item class Object\\
			\extends []
			\begi
				\item \descr
					\pl{Dowolny obiekt}
					\en{Any object}
				\item \opers
				\begi
					\item\verb+.+\\
						\args (Object a, SoftLink s)\\
						\returns DotFunc\\
						\descr
						\pl{Tworzenie obiektu DotFunc.}
						\en{DotFunc creation.}
					\item\verb+;+\\
						\args (Object a, Object b)\\
						\returns Object\\
						\descr
						\pl{Zwraca obiekt b.}
						\en{It returns b object.}
					\item\verb+,+\\
						\args (Object a, Object b)\\
						\returns Object\\
						\descr
						\pl{Tworzenie krotki.}
						\en{Tuple creation.}
					\item\verb+;+\\
						\args (Reference a, Reference b, Reference c)\\
						\returns Number\\
						\descr
						\pl{Zamiana miejscami zmiennych a oraz b.}
						\en{Swapping a and b.}
					\item\verb+:+\\
						\args (Object a, Object b)\\
						\returns Pair\\
						\descr
						\pl{Tworzenie pary.}
						\en{Pair creation.}
					\item\verb+<=>+\\
						\args (Object a, Object b)\\
						\returns Number\\
						\descr
						\pl{Zwraca 1 gdy a jest większe od b, 0 gdy równe, -1 gdy mniejsze.}
						\en{It returns 1 if a is greater than b, 0 if equal, -1 if less.}
					\item\verb+>=+\\
						\args (Object a, Object b)\\
						\returns Boolean\\
						\descr
						\pl{Informuje czy a jest większe bądź równe b.}
						\en{It informs whether a is greater or equal to b.}
					\item\verb+>+\\
						\args (Object a, Object b)\\
						\returns Boolean\\
						\descr
						\pl{Informuje czy a jest większe od b.}
						\en{It informs whether a is greater then b.}
					\item\verb+<=+\\
						\args (Object a, Object b)\\
						\returns Boolean\\
						\descr
						\pl{Informuje czy a jest mniejsze bądź równe b.}
						\en{It informs whether a is less or equal to b.}
					\item\verb+<+\\
						\args (Object a, Object b)\\
						\returns Boolean\\
						\descr
						\pl{Informuje czy a jest mniejsze od b.}
						\en{It informs whether a is less than b.}
					\item\verb+!=+\\
						\args (Object a, Object b)\\
						\returns Boolean\\
						\descr
						\pl{Informuje czy a jest różne od b.}
						\en{It informs whether a is not equal to b.}
					\item\verb+==+\\
						\args (Object a, Object b)\\
						\returns Boolean\\
						\descr
						\pl{Informuje czy a równe b.}
						\en{It informs whether a equal to b.}
					\item\verb+===+\\
						\args (Object a, Object b)\\
						\returns Boolean\\
						\descr
						\pl{Informuje czy a jest b (ten sam obiekt).}
						\en{It informs whether a is b (the same object).}
					\item\verb+&&+\\
						\args (Reference r)\\
						\returns Pointer\\
						\descr
						\pl{Zwraca wskaźnik do r.}
						\en{It returns the pointer to r.}
					\item\verb+:=+\\
						\args (Object a, Object b)\\
						\returns Object\\
						\descr
						\pl{Klonowanie b do a, można klonować całe krotki.}
						\en{Cloning b into a, you can clone all the tuples.}
					\item\verb+=+\\
						\args (Object a, Object b)\\
						\returns Boolean\\
						\descr
						\pl{Przypisywanie b do a (referencja, można przypisywać całe krotki).}
						\en{Ascharactering b to a (reference, you can ascharacter all the tuples).}
				\enit
				\item \methods
				\begi
					\item class\\
						\args (Object o)\\
						\returns Class\\
						\descr
						\pl{Zwraca klasę obiektu o.}
						\en{It returns the class of o object.}
					\item print\\
						\args (Object o)\\
						\returns Object\\
						\descr
						\pl{Wypisanie o do konsoli.}
						\en{Printing o to the console.}
					\item printl\\
						\args (Object o)\\
						\returns Object\\
						\descr
						\pl{Wypisanie o do konsoli jako nowej linii.}
						\en{Printing the o to the console as the new line.}
					\item clone\\
						\args (Object o)\\
						\returns Object\\
						\descr
						\pl{Klonowanie.}
						\en{Cloning.}
					\item lent\\
						\args (Object o)\\
						\returns Number\\
						\descr
						\pl{Zwraca długość o (dla krotek (Tuple) długość krotki, dla obiektu Empty 0, dla obiektów innych klas 1).}
						\en{It returns the length of o (for Tuple object length of the tuple, for Empty object 0, for other classes objects 1.}
					\item set\\
						\args (Object o)\\
						\returns Set\\
						\descr
						\pl{Tworzenie zbioru (\textit{Set}).}
						\en{Set creation..}
					\item dic\\
						\args (Object o)\\
						\returns Dictionary\\
						\descr
						\pl{Tworzenie słownika.}
						\en{Dictionary creation.}
				\enit
			\enit


			\item class Package\\
			\extends [Object]
			\begi
				\item \descr
					\pl{Pakiet (kolekcja klas i innych pakietów)}
					\en{Package (collection of classes and other packages)}
				\item \opers
				\item \methods
				\begi
					\item package\\
						\args (Package p)\\
						\returns Package\\
						\descr
						\pl{Zwraca nadrzędny pakiet.}
						\en{It returns the parent package.}
				\enit
				\item \consts
				\begi
					\item true\\
						\descr
						\pl{Prawda}
						\en{True}
					\item false\\
						\descr
						\pl{Fałsz}
						\en{False}
				\enit
			\enit


			\item class Pair\\
			\extends [Object]
			\begi
				\item \descr
					\pl{Uporządkowana para (klucz, wartość)}
					\en{Ordered pair (key, value)}
				\item \methods
				\begi
					\item key\\
						\args (Pair p)\\
						\returns Object\\
						\descr
						\pl{Zwraca klucz.}
						\en{It returns the key.}
					\item value\\
						\args (Pair p)\\
						\returns Object\\
						\descr
						\pl{Zwraca wartość.}
						\en{It returns the value.}
				\enit
			\enit


			\item class Pointer\\
			\extends [Object]
			\begi
				\item \descr
					\pl{Wskaźnik do obiektu}
					\en{Pointer to an object}
				\item \opers
				\begi
					\item\verb+**+\\
						\args (Pointer p)\\
						\returns Object\\
						\descr
						\pl{Zwraca obiekt, na który wskazuje wskaźnik p.}
						\en{It returns the object that p pointer points to.}
				\enit
			\enit


			\item class Procedure\\
			\extends [Object]
			\begi
				\item \descr
					\pl{Procedura, która przyjmuje parametry i zwraca wartość}
					\en{Procedure that gives parameters and returns a value}
				\item \methods
				\begi
					\item apply\\
						\args (Procedure p)\\
						\returns Object\\
						\descr
						\pl{Wywołanie procedury bez parametrów.}
						\en{Calling procedure without parameters.}
					\item applyF\\
						\args (Procedure p, List l)\\
						\returns Object\\
						\descr
						\pl{Wywołanie procedury z parametrów.}
						\en{Calling procedure with parameters.}
					\item while\\
						\args (Procedure a, Procedure b)\\
						\returns Object\\
						\descr
						\pl{Pętla \textit{while}, warunek określa procedura a, w pętli wykonywana jest procedura b.}
						\en{\textit{while} loop, \textit{a} procedure determines the condition, \textit{b} procedure is executed inside.}
					\item integral\\
						\args (Procedure p, Number beg, Number end)\\
						\returns Object\\
						\descr
						\pl{Całkowanie numeryczne.}
						\en{Numerical integral.}
					\item time\\
						\args (Procedure p)\\
						\returns Number\\
						\descr
						\pl{Zlicza czas wykonywania procedury p w milisekundach.}
						\en{It counts p procedure executing time in milliseconds.}
				\enit
			\enit

			\item class Reference\\
			\extends [Object]
			\begi
				\item \descr
					\pl{Referencja do obiektu, pomocnicza klasa, każdy obiekt ma referencję, ale żaden obiekt nie jest klasy Reference.}
					\en{Reference to an object, an additional class, 
					each object has a reference but no object is an instance of the Reference class.}
			\enit


			\item class Set\\
			\extends [Object]
			\begi
				\item \descr
					\pl{Kolekcja zbiór}
					\en{Set collection}
				\item \opers
				\begi
					\item\verb+<<+\\
						\args (Set s, Object o)\\
						\returns Object\\
						\descr
						\pl{Wrzucenie obiektu o do zbioru s}
						\en{Pushing o object to s set.}
				\enit
				\item \methods
				\begi
					\item len\\
						\args (Set s)\\
						\returns Object\\
						\descr
						\pl{Zwraca długość zbioru.}
						\en{It returns the set length.}
					\item max\\
						\args (Set s)\\
						\returns Object\\
						\descr
						\pl{Zwraca maksymalną wartość.}
						\en{It returns the max value.}
					\item min\\
						\args (Set s)\\
						\returns Object\\
						\descr
						\pl{Zwraca minimalną wartość.}
						\en{It returns the min value.}
					\item contains\\
						\args (Set s, Object o)\\
						\returns Boolean\\
						\descr
						\pl{Informuje czy zbiór zawiera podaną wartość.}
						\en{It informs whether the set contains the value.}
					\item join\\
						\args (Set a, Set b)\\
						\returns Set\\
						\descr
						\pl{Iloczyn zbiorów.}
						\en{Set intersection.}
					\item except\\
						\args (Set a, Set b)\\
						\returns Set\\
						\descr
						\pl{Różnica zbiorów.}
						\en{Set complement.}
					\item union\\
						\args (Set a, Set b)\\
						\returns Set\\
						\descr
						\pl{Suma zbiorów.}
						\en{Set union.}
					\item remove\\
						\args (Set s, Object o)\\
						\returns Object\\
						\descr
						\pl{Zwraca zbiór z usuniętą wartością.}
						\en{It returns the set with removed value.}
					\item toList\\
						\args (Set s)\\
						\returns Object\\
						\descr
						\pl{Konwersja do listy.}
						\en{Conversion to list.}
					\item len\\
						\args (Set s)\\
						\returns Object\\
						\descr
						\pl{Zwraca długość zbioru.}
						\en{It returns the set length.}
				\enit
			\enit


			\item class SoftLink\\
			\extends [Object]
			\begi
				\item \descr
					\pl{Link symboliczny}
					\en{Soft link}
				\item \opers
				\begi
					\item\verb+^^+\\
						\args (SoftLink s, Object o)\\
						\returns Object\\
						\descr
						\pl{Wykonanie procedury wskazywanej przez link dla podanych argumentów.}
						\en{Execution of the procedure pointer by the link for the arguments.}
				\enit
			\enit


			\item class String\\
			\extends [Object]
			\begi
				\item \descr
					\pl{Łańcuch tekstowy}
					\en{Text string}
				\item \opers
				\begi
					\item\verb|+|\\
						\args (String s, Object o)\\
						\returns String\\
						\descr
						\pl{Konkatenacja.}
						\en{Concatenation.}
					\item\verb+*+\\
						\args (String s, Number n)\\
						\returns String\\
						\descr
						\pl{N-krotne kopiowanie.}
						\en{N-times copying.}
					\item\verb+#+\\
						\args (String s)\\
						\returns Object\\
						\descr
						\pl{Podstawienie obliczonych wartości w środku stringa.}
						\en{Inserting of calculated values inside the string.}
					\item\verb+=~+\\
						\args (String regex, String s)\\
						\returns Boolean\\
						\descr
						\pl{Informuje czy string s zawiera wyrażenie regularne regex.}
						\en{It informs whether s string matches regex Regex.}
				\enit
				\item \methods
				\begi
					\item len\\
						\args (String s)\\
						\returns Number\\
						\descr
						\pl{Zwraca długość stringa.}
						\en{It returns the string length.}
					\item get\\
						\args (String s, Number n)\\
						\returns String\\
						\descr
						\pl{Zwraca n-ty znak.}
						\en{It returns the n-th character.}
					\item reverse\\
						\args (String s)\\
						\returns String\\
						\descr
						\pl{Zwraca odwróconego stringa.}
						\en{It returns the reversed string.}
					\item ord\\
						\args (String s)\\
						\returns Number\\
						\descr
						\pl{Zwraca kod ASCII pierwszego znaku.}
						\en{It returns the ASCII code of the first character.}
					\item fromF\\
						\args (String s)\\
						\returns String\\
						\descr
						\pl{Wczytuje zawartość pliku do stringa.}
						\en{It reads the file content into string.}
					\item toF\\
						\args (String s, String f)\\
						\returns Boolean\\
						\descr
						\pl{Zapisuje stringa s do pliku f, zwracana wartość informuje czy zapis się udał.}
						\en{It writes s string to f file, the returned value informs about the success.}
					\item put\\
						\args (String f, String s)\\
						\returns Boolean\\
						\descr
						\pl{Zapisuje stringa s do pliku f, zwracana wartość informuje czy zapis się udał.}
						\en{It writes s string to f file, the returned value informs about the success.}
					\item putA\\
						\args (String f, String s)\\
						\returns Boolean\\
						\descr
						\pl{Dopisuje stringa s do pliku f, zwracana wartość informuje czy zapis się udał.}
						\en{It appends s string to f file, the returned value informs about the success.}
					\item append\\
						\args (String s, String f)\\
						\returns Boolean\\
						\descr
						\pl{Dopisuje stringa s do pliku f, zwracana wartość informuje czy zapis się udał.}
						\en{It appends s string to f file, the returned value informs about the success.}
					\item load\\
						\args (String s)\\
						\returns Object\\
						\descr
						\pl{Wykonuje moduł zapisany w pliku.}
						\en{It executes the module written in a file.}
					\item eval\\
						\args (String s)\\
						\returns Object\\
						\descr
						\pl{Wykonuje kod zawarty w stringu.}
						\en{It returns the code inside a string.}
				\enit
			\enit


			\item class Tuple\\
			\extends [Object]
			\begi
				\item \descr
					\pl{Kolekcja krotka, każda krotka posiada przynajmniej 2 elementy.}
					\en{Tuple collection, each tuple contains minimum 2 elements.}
			\enit

	\enit

\enit

\section{
	\pl{Dla programisty}
	\en{Developer specification}
}

\subsection {
	\pl{Jak ściągnąć, skompilować i uruchomić?}
	\en{How to download, compile and run?}
}

\begin{enumerate}
	\item
		\pl{Zainstaluj dowolną dystrybucję systemu operacyjnego GNU/Linux (dalsze instrukcje dla pochodnych Debiana).
		Możesz skorzystać ze strony}
		\en{Install any distribution of GNU/Linux operating system (following instructions for Debian derivatives).
		You can use}
		: \url{http://www.linuxmint.com/download.php}.
	\item
		\pl{Zainstaluj mono. Użyj polecenia terminala}
		\en{Install mono. Use terminal commmand}
		: \textit{sudo apt-get install monodevelop mono-complete}.
	\item
		\pl{Zainstaluj git}
		\en{Install git}
		: \textit{sudo apt-get install git}
	\item
		\pl{Utwórz nowy folder i wejdź do niego}
		\en{Create a new directory and go inside it}
		: \textit{mkdir project1; cd project1}
	\item
		\pl{Ściągnij projekt}
		\en{Download the project}
		: \textit{git download https://github.com/oprogramador/repo.git; cd repo}
	\item
		\pl{Skompiluj}
		\en{Compile}
		: \textit{./make.sh}
	\item
		\pl{Uruchom}
		\en{Run}
		: \textit{./plezuro.exe}
\end{enumerate}
\en{You can also try compiling it on Windows using either Visual Studio or Mono.}
\pl{Możesz również spróbować skompilować w systemie Windows używając Visual Studio lub Mono.}

\subsection{
	\pl{Kod}
	\en{Code}
}

\subsubsection{
	\pl{Pliki, przestrzenie nazw (odpowiadają folderom), klasy, interfejsy, enumeracje, dziedziczenie}
	\en{Files, namespaces (adequate to directories), classes, interfaces, enumerations, inheritance}
}

\verbatiminput{code.tex}

\end{document}
